################################################################################
# PromptForge PostgreSQL Configuration
################################################################################
#
# Optimized for on-premises deployment with moderate workload
# Adjust values based on your hardware specifications
#
# Target System Specs (adjust accordingly):
#   - RAM: 8GB (dedicated to PostgreSQL: 2GB)
#   - CPU: 4 cores
#   - Storage: SSD
#
# Usage:
#   1. Copy to postgresql.conf location (usually /etc/postgresql/*/main/)
#   2. Adjust values based on actual hardware
#   3. Restart PostgreSQL: sudo systemctl restart postgresql
#
################################################################################

#------------------------------------------------------------------------------
# CONNECTION SETTINGS
#------------------------------------------------------------------------------

# Maximum number of concurrent connections
# Formula: (RAM in GB * 30) for moderate workload
max_connections = 100

# Minimum number of connections reserved for superuser
superuser_reserved_connections = 3

#------------------------------------------------------------------------------
# MEMORY SETTINGS
#------------------------------------------------------------------------------

# Shared memory used for caching data
# Formula: 25% of total RAM
# For 8GB RAM: 2GB
shared_buffers = 2GB

# Memory for complex sorts and hash tables (per operation)
# Formula: RAM / max_connections
# For 8GB RAM and 100 connections: ~80MB, but 16MB is reasonable
work_mem = 16MB

# Memory for maintenance operations (VACUUM, CREATE INDEX, etc.)
# Formula: 5% of RAM
maintenance_work_mem = 512MB

# Memory for autovacuum workers
# Should be equal to maintenance_work_mem
autovacuum_work_mem = 512MB

# Maximum memory for prepared transactions (if used)
# Usually not needed unless using two-phase commit
# max_prepared_transactions = 0

# Maximum stack depth (rarely needs adjustment)
# max_stack_depth = 2MB

# Shared memory for tracking query execution statistics
# Requires pg_stat_statements extension
shared_preload_libraries = 'pg_stat_statements'
pg_stat_statements.max = 10000
pg_stat_statements.track = all

#------------------------------------------------------------------------------
# QUERY PLANNER
#------------------------------------------------------------------------------

# Cost of random page fetch
# SSD: 1.1, HDD: 4.0
random_page_cost = 1.1

# Cost of sequential page fetch
seq_page_cost = 1.0

# Planner's assumption about cache effectiveness
# Formula: 50-75% of RAM
# For 8GB RAM: 4GB
effective_cache_size = 4GB

# Number of simultaneous requests that can be handled efficiently by disk
# SSD: number of cores * 2
# HDD: 2-4
effective_io_concurrency = 8

# Number of parallel workers for a query
# Set to number of CPU cores
max_worker_processes = 4
max_parallel_workers_per_gather = 2
max_parallel_workers = 4

# Enable parallel queries for maintenance operations
max_parallel_maintenance_workers = 2

# Default statistics target for columns
# Higher = better query plans, slower ANALYZE
# 100 is good for most cases
default_statistics_target = 100

#------------------------------------------------------------------------------
# WRITE AHEAD LOG (WAL)
#------------------------------------------------------------------------------

# WAL level (minimal, replica, logical)
# Use 'replica' for replication, 'logical' for logical replication
wal_level = replica

# Size of WAL segments
# Default: 16MB, increase for high write workloads
wal_segment_size = 16MB

# Minimum number of past log file segments
# Formula: (2 * checkpoint_segments) + 1
min_wal_size = 1GB

# Maximum size to let WAL grow during checkpoints
# Formula: 3 * checkpoint_segments
max_wal_size = 4GB

# WAL buffers for unflushed WAL data
# Formula: 16MB for systems with 32GB+ RAM, auto for smaller
wal_buffers = 16MB

# Time between WAL flushes
# Lower = more durable, higher = better performance
wal_writer_delay = 200ms

# Commit delay for group commits
# 0 = disabled (recommended for most cases)
commit_delay = 0

# Enable compression of full page writes in WAL
wal_compression = on

# fsync method (fdatasync, fsync, open_sync, etc.)
# fdatasync is fastest on Linux
fsync = on
synchronous_commit = on

# Full page writes (required for crash recovery)
full_page_writes = on

#------------------------------------------------------------------------------
# CHECKPOINTS
#------------------------------------------------------------------------------

# Time between automatic checkpoints
# Longer = fewer I/O spikes, but longer recovery time
checkpoint_timeout = 15min

# Target for checkpoint completion
# 0.9 = spread checkpoint over 90% of checkpoint_timeout
checkpoint_completion_target = 0.9

# Flush pages to disk during checkpoint
checkpoint_flush_after = 256kB

# Warning threshold for checkpoint spacing
# Warn if checkpoints happen more frequently than this
checkpoint_warning = 5min

#------------------------------------------------------------------------------
# BACKGROUND WRITER
#------------------------------------------------------------------------------

# Delay between background writer rounds
bgwriter_delay = 200ms

# Max buffers written per round
bgwriter_lru_maxpages = 100

# Multiplier for buffer usage scan
bgwriter_lru_multiplier = 2.0

# Flush pages after writing this many bytes
bgwriter_flush_after = 512kB

#------------------------------------------------------------------------------
# AUTOVACUUM
#------------------------------------------------------------------------------

# Enable autovacuum daemon
autovacuum = on

# Time between autovacuum runs
autovacuum_naptime = 1min

# Minimum number of tuple updates/deletes before vacuum
autovacuum_vacuum_threshold = 50

# Minimum number of tuple inserts/updates/deletes before analyze
autovacuum_analyze_threshold = 50

# Fraction of table size to add to thresholds
autovacuum_vacuum_scale_factor = 0.1
autovacuum_analyze_scale_factor = 0.05

# Maximum number of autovacuum workers
# Should not exceed max_worker_processes
autovacuum_max_workers = 3

# Vacuum cost delay (throttling)
# 0 = no delay (use all available I/O)
autovacuum_vacuum_cost_delay = 2ms

# Vacuum cost limit
autovacuum_vacuum_cost_limit = 200

# Freeze ages to prevent transaction ID wraparound
autovacuum_freeze_max_age = 200000000
autovacuum_multixact_freeze_max_age = 400000000

#------------------------------------------------------------------------------
# LOGGING
#------------------------------------------------------------------------------

# Where to log
log_destination = 'stderr'
logging_collector = on
log_directory = 'log'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'

# Log rotation
log_truncate_on_rotation = off
log_rotation_age = 1d
log_rotation_size = 100MB

# When to log
log_min_messages = warning
log_min_error_statement = error
log_min_duration_statement = 1000  # Log queries slower than 1 second

# What to log
log_checkpoints = on
log_connections = on
log_disconnections = on
log_duration = off
log_line_prefix = '%t [%p]: user=%u,db=%d,app=%a,client=%h '
log_lock_waits = on
log_statement = 'ddl'  # Log DDL statements
log_temp_files = 0  # Log all temp files

# Log slow queries
log_min_duration_statement = 1000  # 1 second

# Auto-explain slow queries
auto_explain.log_min_duration = 1000
auto_explain.log_analyze = on
auto_explain.log_buffers = on
auto_explain.log_timing = off
auto_explain.log_triggers = on
auto_explain.log_verbose = off
auto_explain.log_nested_statements = on

#------------------------------------------------------------------------------
# LOCK MANAGEMENT
#------------------------------------------------------------------------------

# Maximum number of locks per transaction
max_locks_per_transaction = 64

# Deadlock timeout (time to wait before checking for deadlock)
deadlock_timeout = 1s

#------------------------------------------------------------------------------
# CLIENT CONNECTION DEFAULTS
#------------------------------------------------------------------------------

# Default transaction isolation level
default_transaction_isolation = 'read committed'

# Statement timeout (0 = disabled)
# Set at database or role level instead
# statement_timeout = 0

# Lock timeout (0 = disabled)
# lock_timeout = 0

# Idle in transaction timeout
idle_in_transaction_session_timeout = 60s

# Client encoding
client_encoding = 'UTF8'

# Locale settings
lc_messages = 'en_US.UTF-8'
lc_monetary = 'en_US.UTF-8'
lc_numeric = 'en_US.UTF-8'
lc_time = 'en_US.UTF-8'

# Timezone
timezone = 'UTC'

#------------------------------------------------------------------------------
# REPLICATION (if needed)
#------------------------------------------------------------------------------

# Maximum number of WAL sender processes
max_wal_senders = 3

# Maximum number of replication slots
max_replication_slots = 3

# Standby server settings (on replica)
# hot_standby = on
# max_standby_archive_delay = 30s
# max_standby_streaming_delay = 30s

# WAL receiver settings
# wal_receiver_status_interval = 10s
# hot_standby_feedback = on

#------------------------------------------------------------------------------
# SECURITY
#------------------------------------------------------------------------------

# SSL/TLS settings (if using encrypted connections)
# ssl = on
# ssl_cert_file = '/etc/ssl/certs/postgresql.crt'
# ssl_key_file = '/etc/ssl/private/postgresql.key'
# ssl_ca_file = '/etc/ssl/certs/ca.crt'
# ssl_ciphers = 'HIGH:MEDIUM:+3DES:!aNULL'
# ssl_prefer_server_ciphers = on

# Password encryption method
password_encryption = scram-sha-256

#------------------------------------------------------------------------------
# RESOURCE LIMITS
#------------------------------------------------------------------------------

# Temporary file limit per session (prevents runaway queries)
temp_file_limit = 10GB

#------------------------------------------------------------------------------
# COST-BASED VACUUM DELAY
#------------------------------------------------------------------------------

# Vacuum cost delay (throttling)
vacuum_cost_delay = 0  # 0 = no delay for manual VACUUM

# Cost limit before vacuum pauses
vacuum_cost_limit = 200

# Cost parameters for various operations
vacuum_cost_page_hit = 1
vacuum_cost_page_miss = 10
vacuum_cost_page_dirty = 20

#------------------------------------------------------------------------------
# PERFORMANCE MONITORING
#------------------------------------------------------------------------------

# Track activity across sessions
track_activities = on
track_counts = on
track_io_timing = on
track_functions = all

# Track activity query size
track_activity_query_size = 4096

#------------------------------------------------------------------------------
# ERROR HANDLING
#------------------------------------------------------------------------------

# Action on out of memory
# abort - abort transaction (default)
# panic - force database restart
exit_on_error = off

# Restart after backend crash
restart_after_crash = on

################################################################################
# TUNING GUIDELINES
################################################################################
#
# For high-write workloads:
#   - Increase shared_buffers (up to 40% of RAM)
#   - Increase wal_buffers (16MB-64MB)
#   - Increase checkpoint_timeout (30min)
#   - Increase max_wal_size (8GB-16GB)
#
# For high-read workloads:
#   - Increase effective_cache_size (75% of RAM)
#   - Increase default_statistics_target (200-500)
#   - Enable parallel queries aggressively
#
# For SSDs:
#   - Set random_page_cost = 1.1
#   - Increase effective_io_concurrency = cores * 2
#   - Disable or reduce checkpoint_flush_after
#
# For HDDs:
#   - Set random_page_cost = 4.0
#   - Set effective_io_concurrency = 2-4
#   - Increase checkpoint_timeout
#
################################################################################
